import math

import numpy as np

"""
Boat3DOF: A 3-DOF surface vessel dynamics model (surge, sway, yaw).

The model uses the standard marine craft equations:

    m * u_dot - m * v * r = X - Xu*u - Xuu*|u|*u
    m * v_dot + m * u * r = Y - Yv*v - Yr*r
    Iz * r_dot            = N - Nv*v - Nr*r

GENERALIZED FORCES (X, Y, N):
 Rotor-to-force mapping:
    thrust : Rotor force magnitude [N]
    delta  : Rotor angle [rad] relative to body +x (CCW positive).

    X : Surge force  [N]
        Positive along the boat's +x axis (forward).
        Computed from the rotor inputs as:
            X = thrust * cos(delta)

    Y : Sway force   [N]
        Lateral force along the +y axis (port/left, ROS FLU).
        Computed from the rotor inputs as:
            Y = thrust * sin(delta)

    N : Yaw moment   [N·m]
        Turning moment about the vertical z-axis from the stern rotor.
        If the rotor is placed behind the CG at x = -l:
            N = (-l) * Y = -l * thrust * sin(delta)

MODEL PARAMETERS (provided via `params`):

    m   : Vessel mass [kg]
    Iz  : Yaw moment of inertia [kg·m²]

    Xu  : Linear surge damping (viscous drag)
    Xuu : Quadratic surge damping (form drag)

    Yv  : Linear sway damping (lateral hydrodynamic resistance)
    Yr  : Cross-coupling damping from yaw rate to sway force

    Nv  : Yaw moment generated by sway velocity
    Nr  : Yaw rotational damping (hydrodynamic)

    l   : Distance from CG to rotor along +x [m] (use positive scalar).
          Rotor is assumed located at x = -l (aft of CG).

STATE VECTOR:

    state = [x, y, psi, u, v, r]

    x, y : Inertial position in world frame (ENU)
    psi  : Heading angle (yaw) [rad]
    u    : Surge velocity (forward) [m/s]
    v    : Sway velocity (sideways, +y port/left) [m/s]
    r    : Yaw rate [rad/s]

The model is sufficient for control system design, trajectory following,
and simulation of underactuated surface vessels using only CPU resources.
"""


class Boat3DOF:
    def __init__(self, params):
        self.m = params["m"]
        self.Iz = params["Iz"]
        self.Xu = params["Xu"]
        self.Xuu = params["Xuu"]
        self.Yv = params["Yv"]
        self.Yr = params["Yr"]
        self.Nv = params["Nv"]
        self.Nr = params["Nr"]
        self.rotor_arm = params["l"]

        # state = [x, y, psi, u, v, r]
        self.state = np.zeros(6, dtype=float)

    def dynamics(self, state, thrust, delta):
        x, y, psi, u, v, r = state

        # Kinematics
        dx = u * np.cos(psi) - v * np.sin(psi)
        dy = u * np.sin(psi) + v * np.cos(psi)
        dpsi = r

        # Input to generalized forces
        thrust = float(thrust)
        delta = float(delta)
        X = thrust * math.cos(delta)
        Y = thrust * math.sin(delta)
        N = -self.rotor_arm * Y

        # Surge
        du = (X
              - self.Xu * u
              - self.Xuu * abs(u) * u
              + self.m * v * r) / self.m

        # Sway
        dv = (Y
              - self.Yv * v
              - self.Yr * r
              - self.m * u * r) / self.m

        # Yaw
        dr = (N
              - self.Nv * v
              - self.Nr * r) / self.Iz

        return np.array([dx, dy, dpsi, du, dv, dr], dtype=float)

    def step(self, thrust, delta, dt):
        s = self.state
        k1 = self.dynamics(s, thrust, delta)
        k2 = self.dynamics(s + 0.5 * dt * k1, thrust, delta)
        k3 = self.dynamics(s + 0.5 * dt * k2, thrust, delta)
        k4 = self.dynamics(s + dt * k3, thrust, delta)
        self.state = s + dt * (k1 + 2 * k2 + 2 * k3 + k4) / 6.0
        return self.state

import numpy as np

"""
Boat3DOF: A 3-DOF surface vessel dynamics model (surge, sway, yaw).

The model uses the standard marine craft equations:

    m * u_dot - m * v * r = X - Xu*u - Xuu*|u|*u
    m * v_dot + m * u * r = Y - Yv*v - Yr*r
    Iz * r_dot            = N - Nv*v - Nr*r

GENERALIZED FORCES (X, Y, N):
 Thruster-to-force mapping:
    T_L : Left thruster force [N]
    T_R : Right thruster force [N]

    X : Surge force  [N]
        Positive along the boat's +x axis (forward).
        Computed from the thruster inputs as:
            X = T_L + T_R

    Y : Sway force   [N]
        Lateral force along the +y axis.
        For a symmetric twin-thruster robot with no side thrusters:
            Y = 0
        (A rudder or side thruster would contribute here.)

    N : Yaw moment   [N·m]
        Turning moment about the vertical z-axis.
        For differential thrust:
            N = l * (T_R - T_L)
        where l is half the distance between left and right thrusters.

MODEL PARAMETERS (provided via `params`):

    m   : Vessel mass [kg]
    Iz  : Yaw moment of inertia [kg·m²]

    Xu  : Linear surge damping (viscous drag)
    Xuu : Quadratic surge damping (form drag)

    Yv  : Linear sway damping (lateral hydrodynamic resistance)
    Yr  : Cross-coupling damping from yaw rate to sway force

    Nv  : Yaw moment generated by sway velocity
    Nr  : Yaw rotational damping (hydrodynamic)

    l   : Half-beam distance between thrusters [m]
          Used to convert differential thrust into yaw moment.

STATE VECTOR:

    state = [x, y, psi, u, v, r]

    x, y : Inertial position in world frame
    psi  : Heading angle (yaw) [rad]
    u    : Surge velocity (forward) [m/s]
    v    : Sway velocity (sideways) [m/s]
    r    : Yaw rate [rad/s]

The model is sufficient for control system design, trajectory following,
and simulation of underactuated surface vessels using only CPU resources.
"""


class Boat3DOF:
    def __init__(self, params):
        self.m = params["m"]
        self.Iz = params["Iz"]
        self.Xu = params["Xu"]
        self.Xuu = params["Xuu"]
        self.Yv = params["Yv"]
        self.Yr = params["Yr"]
        self.Nv = params["Nv"]
        self.Nr = params["Nr"]
        self.thruster_arm = params["l"]

        # state = [x, y, psi, u, v, r]
        self.state = np.zeros(6, dtype=float)

    def dynamics(self, state, T_L, T_R):
        x, y, psi, u, v, r = state

        # Kinematics
        dx = u * np.cos(psi) - v * np.sin(psi)
        dy = u * np.sin(psi) + v * np.cos(psi)
        dpsi = r

        # Input to generalized forces
        X = T_L + T_R
        Y = 0.0
        N = self.thruster_arm * (T_R - T_L)

        # Surge
        du = (X
              - self.Xu * u
              - self.Xuu * abs(u) * u
              + self.m * v * r) / self.m

        # Sway
        dv = (Y
              - self.Yv * v
              - self.Yr * r
              - self.m * u * r) / self.m

        # Yaw
        dr = (N
              - self.Nv * v
              - self.Nr * r) / self.Iz

        return np.array([dx, dy, dpsi, du, dv, dr], dtype=float)

    def step(self, T_L, T_R, dt):
        s = self.state
        k1 = self.dynamics(s, T_L, T_R)
        k2 = self.dynamics(s + 0.5 * dt * k1, T_L, T_R)
        k3 = self.dynamics(s + 0.5 * dt * k2, T_L, T_R)
        k4 = self.dynamics(s + dt * k3, T_L, T_R)
        self.state = s + dt * (k1 + 2 * k2 + 2 * k3 + k4) / 6.0
        return self.state

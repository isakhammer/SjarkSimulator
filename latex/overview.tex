\documentclass[11pt]{article}

\usepackage[a4paper,margin=25mm]{geometry}
\usepackage{amsmath,amssymb}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage[nameinlink,noabbrev]{cleveref}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,calc,positioning}

\title{Nautomatic: Control \& Simulation Overview}
\author{Nautomatic contributors}
\date{\today}

\begin{document}
\maketitle

\section{Scope}
This document provides a math-first description of the controller, simulator,
and B-spline utilities. It is not an API reference, but it includes examples,
edge cases, and limitations so expectations and tuning tradeoffs are explicit.

\begin{itemize}
  \item Dynamics model: \texttt{src/na\_sim/na\_sim/Boat3DOF.py}
  \item Simulator node: \texttt{src/na\_sim/na\_sim/sim\_node.py}
  \item Planner node: \texttt{src/na\_planner/na\_planner/planner\_node.py}
  \item Controller node: \texttt{src/na\_controller/na\_controller/controller\_node.py}
  \item B-spline utilities: \texttt{src/na\_utils/na\_utils/bspline.py}
  \item Default parameters: \texttt{src/na\_launch/config/sim\_controller\_params.yaml}
\end{itemize}

\section{System architecture (ROS 2)}
The stack is a minimal closed loop:
\begin{itemize}
  \item The planner publishes a reference path (uniform cubic B-spline control points).
  \item The controller projects the current boat position onto the path, computes a lookahead target, and outputs actuator commands.
  \item The simulator integrates the vessel dynamics and publishes state/odometry.
  \item Visualization nodes render the path, projection, CTE, and boat pose.
\end{itemize}

\subsection{Key topics}
\begin{itemize}
  \item \texttt{/planner\_ns/path} (\texttt{na\_msg/BsplinePath}) --- path control points.
  \item \texttt{/boat\_state} (\texttt{std\_msgs/Float32MultiArray}) --- state vector $[x,y,\psi,u,v,r]$.
  \item \texttt{/cmd\_thrust} (\texttt{std\_msgs/Float32MultiArray}) --- actuator command $[T,\delta]$.
  \item \texttt{/controller\_ns/controller\_state} (\texttt{na\_msg/ControllerState}) --- debug projection/CTE data.
  \item \texttt{/odom} (\texttt{nav\_msgs/Odometry}) and TF \texttt{map} $\rightarrow$ \texttt{base\_link}.
\end{itemize}

\subsection{Data flow diagram}
\Cref{fig:architecture} summarizes the main signals.
\begin{figure}[h]
  \centering
  \begin{tikzpicture}[>=Latex,node distance=2.4cm]
    \node[draw,rounded corners,align=center,minimum width=3.0cm] (planner) {Planner\\\texttt{BsplinePath}};
    \node[draw,rounded corners,align=center,minimum width=3.0cm,right=of planner] (controller) {Controller\\LOS guidance};
    \node[draw,rounded corners,align=center,minimum width=3.0cm,right=of controller] (sim) {Simulator\\Boat3DOF};
    \node[draw,rounded corners,align=center,minimum width=2.4cm,below=1.4cm of controller] (viz) {Visualization};

    \draw[->] (planner) -- node[above] {\texttt{/planner\_ns/path}} (controller);
    \draw[->] (controller) -- node[above] {\texttt{/cmd\_thrust}} (sim);
    \draw[->] (sim) -- node[above] {\texttt{/boat\_state}} (controller);
    \draw[->,dashed] (sim) -- node[right] {\texttt{/odom}, TF} (viz);
    \draw[->,dashed] (planner) -- (viz);
    \draw[->,dashed] (controller) -- (viz);
  \end{tikzpicture}
  \caption{Data flow between the planner, controller, simulator, and visualization.}
  \label{fig:architecture}
\end{figure}

\section{Frames, signals, and conventions}
The simulator uses a planar world frame \emph{map} and a body frame \emph{base\_link}:
\begin{itemize}
  \item $x,y$ are inertial positions in the map frame (meters).
  \item $\psi$ is the heading/yaw angle (radians, CCW positive).
  \item $u,v$ are body-frame surge/sway velocities (m/s).
  \item $r$ is yaw rate (rad/s).
\end{itemize}

The actuator is a stern-mounted steerable rotor producing a thrust magnitude $T$
and an angle $\delta$ relative to body $+x$ (positive CCW).

\section{3-DOF vessel model}
\subsection{State}
The state vector used in the simulator is
\[
  \mathbf{x} = [x,\; y,\; \psi,\; u,\; v,\; r]^T.
\]

\subsection{Kinematics}
With body-frame velocities $(u,v)$ and heading $\psi$,
\begin{align}
  \dot{x} &= u\cos\psi - v\sin\psi, \\
  \dot{y} &= u\sin\psi + v\cos\psi, \\
  \dot{\psi} &= r.
\end{align}

\subsection{Input mapping}
The simulator treats the rotor command as thrust magnitude $T$ and steering angle $\delta$.
These are mapped into generalized forces in surge/sway and yaw:
\begin{align}
  X &= T\cos\delta,\\
  Y &= T\sin\delta,\\
  N &= -\ell\,Y,
\end{align}
where $\ell > 0$ is the distance from the center of gravity to the rotor along $+x$ (rotor located at $x=-\ell$).

\subsection{Dynamics}
The implemented model is a standard 3-DOF surface vessel (surge, sway, yaw) with simple linear/quadratic damping:
\begin{align}
  \dot{u} &= \frac{1}{m}\left(X - X_u u - X_{uu}|u|u + mvr\right), \\
  \dot{v} &= \frac{1}{m}\left(Y - Y_v v - Y_r r - mur\right), \\
  \dot{r} &= \frac{1}{I_z}\left(N - N_v v - N_r r\right).
\end{align}

This model assumes planar motion with no heave/roll/pitch, no current or wind,
and no added-mass or nonlinear cross-coupling beyond the terms shown.

\subsection{Force diagram}
\Cref{fig:forces} summarizes the sign conventions and the thrust decomposition.

\begin{figure}[h]
  \centering
  \begin{tikzpicture}[>=Latex,scale=1.05]
    % Hull rectangle (body frame)
    \draw[thick] (-1.8,-0.5) rectangle (1.8,0.5);
    \node[anchor=west] at (1.85,0) {bow};

    % Body axes at CG
    \draw[->,thick] (0,0) -- (1.4,0) node[below] {$+x$};
    \draw[->,thick] (0,0) -- (0,1.2) node[left] {$+y$};

    % Rotor at stern: x = -l
    \def\ell{1.2}
    \coordinate (rotor) at (-\ell,0);
    \fill (rotor) circle (1.6pt);
    \draw[dashed] (0,0) -- (rotor);
    \node[anchor=north east] at (rotor) {rotor};
    \node at (-0.6,0.18) {$\ell$};

    % Thrust vector at delta
    \def\delta{30} % degrees
    \def\T{1.6}    % length scale
    \pgfmathsetmacro{\dx}{\T*cos(\delta)}
    \pgfmathsetmacro{\dy}{\T*sin(\delta)}
    \draw[->,very thick,blue] (rotor) -- ++(\delta:\T) node[above right] {$T$};

    % Components X and Y
    \draw[->,thick,orange] (rotor) -- ++(0:\dx) node[below] {$X=T\cos\delta$};
    \draw[->,thick,green!60!black] ($(rotor)+(0:\dx)$) -- ++(90:\dy)
      node[right] {$Y=T\sin\delta$};

    % Delta arc
    \draw[blue] ($(rotor)+(0.45,0)$) arc (0:\delta:0.45);
    \node[blue] at ($(rotor)+(0.65,0.28)$) {$\delta$};

    % Yaw moment about CG
    \draw[->,thick,red] (0.2,-0.9) arc (-40:220:0.35);
    \node[red] at (0.75,-0.9) {$N=-\ell\,Y$};
  \end{tikzpicture}
  \caption{Thrust decomposition and yaw moment sign convention used by the simulator.}
  \label{fig:forces}
\end{figure}

\section{Simulation}
The simulator node integrates the continuous-time ODE using RK4 with timestep $dt$
(see \texttt{sim\_node.py}) and publishes state and odometry at a fixed timer rate
(default \SI{50}{\hertz}). Inputs are saturated to
$(T,\delta)\in[-T_{\max},T_{\max}]\times[-\delta_{\max},\delta_{\max}]$ and can be rate-limited in $\delta$.

\subsection{Timing and inputs}
The integrator uses the parameter \texttt{dt} as its step size. If the ROS timer
period does not match \texttt{dt}, the simulated dynamics and the publish rate
are no longer synchronized. Commands are held at the last received value.

\subsection{Outputs}
The simulator publishes:
\begin{itemize}
  \item \texttt{/boat\_state} with $[x,y,\psi,u,v,r]$.
  \item \texttt{/odom} with position, yaw-only quaternion, and twist.
  \item TF transform \texttt{map} $\rightarrow$ \texttt{base\_link}.
\end{itemize}

\section{Path representation and projection}
\subsection{Uniform cubic B-spline}
The planner publishes control points for a uniform cubic B-spline. The code
uses a unitless parameter $u = i + t$, where $i=\lfloor u \rfloor$ and
$t \in [0,1)$. The spline value is
\[
  \mathbf{C}(u) = b_0(t)\mathbf{P}_{i-1} + b_1(t)\mathbf{P}_{i}
  + b_2(t)\mathbf{P}_{i+1} + b_3(t)\mathbf{P}_{i+2},
\]
with basis functions:
\begin{align}
  b_0(t) &= \frac{-t^3 + 3t^2 - 3t + 1}{6}, &
  b_1(t) &= \frac{3t^3 - 6t^2 + 4}{6}, \\
  b_2(t) &= \frac{-3t^3 + 3t^2 + 3t + 1}{6}, &
  b_3(t) &= \frac{t^3}{6}.
\end{align}
For closed paths, indices wrap modulo $n$. For open paths, $u$ spans
$[0,\,n-3]$ and clamps at the ends. The \texttt{degree} field in
\texttt{BsplinePath} is currently ignored (uniform cubic is always used).

\subsection{Sampling and arc length}
\texttt{BSplinePath} samples the spline uniformly in $u$ and accumulates
Euclidean distances to approximate arc length $t$ (meters). The sampled arrays
provide fast conversions between $u$ and $t$. The controller uses
\texttt{samples\_from\_density} to select a sample count based on an estimated
path length and the \texttt{samples\_per\_meter} parameter.

\subsection{Projection and Frenet frame}
Projection is a two-stage process:
\begin{enumerate}
  \item Find the nearest sampled point (optionally within a window around a hint).
  \item Refine $u$ with a Gauss-Newton step along the spline tangent:
  \[
    \Delta u = \frac{(\mathbf{p}-\mathbf{C}(u)) \cdot \mathbf{C}'(u)}
      {\mathbf{C}'(u)\cdot\mathbf{C}'(u)}.
  \]
\end{enumerate}
The result provides a Frenet frame with unit tangent $\hat{\mathbf{t}}$,
normal $\hat{\mathbf{n}}$, and signed cross-track error
$cte = (\mathbf{p}-\mathbf{p}_{proj}) \cdot \hat{\mathbf{n}}$.

\subsection{ProjectionTracker}
\texttt{ProjectionTracker} adds state to stabilize sequential projections:
\begin{itemize}
  \item It keeps the last arc-length projection $t$.
  \item It predicts forward progress using body velocities and heading.
  \item It limits jumps via \texttt{max\_jump} and can enforce minimum forward
    progress when the along-track speed is positive.
\end{itemize}
This reduces projection snapping on self-intersections but does not eliminate
all ambiguity.

\section{Controller (LOS-style guidance)}
The controller follows a line-of-sight (LOS) guidance pattern:
\begin{enumerate}
  \item If no valid spline is available, publish $[0,0]$ and exit.
  \item Project $(x,y)$ onto the path to get $t$, tangent, normal, and $cte$.
  \item Compute the path heading $\psi_{path}$ from the tangent; if the tangent
    norm is near zero, $\psi_{path}=0$.
  \item Choose a lookahead distance $L$ and advance to $t_{target}=t+L$.
  \item Compute desired heading
    \[
      \psi_d = \mathrm{wrap}\left(\psi_{path} - \arctan2(cte, L)\right).
    \]
  \item Apply a PD law on heading error with saturation:
    \[
      \delta = \mathrm{sat}\left(-k_p\,\mathrm{wrap}(\psi_d-\psi) - k_d\,r,\;\delta_{\max}\right).
    \]
  \item Thrust is constant: $T=\mathrm{sat}(T_0, T_{\max})$.
\end{enumerate}
The controller publishes debug values (projection point, CTE, target) on
\texttt{/controller\_ns/controller\_state}.

\section{Configuration parameters}
Default parameters live in \texttt{src/na\_launch/config/sim\_controller\_params.yaml}.
\texttt{config\_path} can override the YAML file for both simulator and controller.

\subsection{Controller parameters}
\begin{table}[h]
  \centering
  \begin{tabular}{@{}llll@{}}
    \toprule
    Parameter & Default & Units & Meaning \\
    \midrule
    \texttt{path\_topic} & \texttt{/planner\_ns/path} & -- & BsplinePath source \\
    \texttt{lookahead} & 4.0 & \si{\meter} & LOS lookahead distance \\
    \texttt{base\_thrust} & 15.0 & \si{\newton} & Constant thrust command \\
    \texttt{heading\_kp} & 2.0 & -- & Heading proportional gain \\
    \texttt{heading\_kd} & 0.5 & \si{\second} & Yaw-rate damping gain \\
    \texttt{max\_thrust} & 30.0 & \si{\newton} & Thrust saturation \\
    \texttt{max\_delta} & 1.570796 & \si{\radian} & Steering saturation \\
    \texttt{samples\_per\_meter} & 4.0 & \si{\per\meter} & B-spline sample density \\
    \texttt{max\_proj\_jump} & 0.2 & \si{\meter} & Projection jump limit \\
    \bottomrule
  \end{tabular}
  \caption{Controller tuning parameters and defaults.}
  \label{tab:controller_params}
\end{table}

\subsection{Simulator parameters}
\begin{table}[h]
  \centering
  \begin{tabular}{@{}llll@{}}
    \toprule
    Parameter & Default & Units & Meaning \\
    \midrule
    \texttt{m} & 70.0 & \si{\kilogram} & Mass \\
    \texttt{Iz} & 10.0 & \si{\kilogram\meter\squared} & Yaw inertia \\
    \texttt{Xu} & 5.0 & -- & Linear surge damping \\
    \texttt{Xuu} & 1.0 & -- & Quadratic surge damping \\
    \texttt{Yv} & 40.0 & -- & Linear sway damping \\
    \texttt{Yr} & 5.0 & -- & Yaw-rate to sway coupling \\
    \texttt{Nv} & 5.0 & -- & Yaw moment from sway velocity \\
    \texttt{Nr} & 40.0 & -- & Yaw rotational damping \\
    \texttt{l} & 0.5 & \si{\meter} & Rotor arm (positive scalar) \\
    \texttt{dt} & 0.02 & \si{\second} & Integration step \\
    \texttt{max\_thrust} & 40.0 & \si{\newton} & Thrust saturation \\
    \texttt{max\_delta} & 1.570796 & \si{\radian} & Steering saturation \\
    \texttt{max\_delta\_rate} & 0.0 & \si{\radian\per\second} & Steering rate limit \\
    \bottomrule
  \end{tabular}
  \caption{Simulator parameters and defaults.}
  \label{tab:sim_params}
\end{table}

\section{Examples and edge cases}
Figures in this section are generated from the same B-spline utilities used by
the controller, via \texttt{latex/scripts/generate\_figures.py}.

\subsection{Example: closed-loop LOS tracking}
\Cref{fig:los_example} illustrates the projection, cross-track error, and
lookahead target on a closed spline generated from the same projection code.
\begin{figure}[h]
  \centering
  \input{figures/los_example.tikz}
  \caption{LOS tracking geometry on a closed spline generated from the path utilities.}
  \label{fig:los_example}
\end{figure}

\subsection{Example: open path end behavior}
\Cref{fig:open_end} shows an open path with the vessel near the end. The
lookahead point clamps at the end of the spline; there is no wrap-around.
\begin{figure}[h]
  \centering
  \input{figures/open_end.tikz}
  \caption{Open-path end behavior: \texttt{advance\_t} clamps instead of wrapping.}
  \label{fig:open_end}
\end{figure}

\subsection{Edge case: sparse sampling}
\Cref{fig:sampling_density} compares a dense spline sample to a coarse sample
count. Sparse samples reduce projection accuracy and can create large cte
discontinuities.
\begin{figure}[h]
  \centering
  \input{figures/sampling_density.tikz}
  \caption{Effect of low sampling density on the spline representation.}
  \label{fig:sampling_density}
\end{figure}

\subsection{Edge cases and expected behavior}
\begin{itemize}
  \item Fewer than 4 control points or mismatched \texttt{ctrl\_x}/\texttt{ctrl\_y} arrays:
    controller rejects the path, outputs $[0,0]$, and resets projection history.
  \item Very low \texttt{samples\_per\_meter} (or non-positive values): the spline is
    still built but with coarse sampling, which degrades projection accuracy (see
    \Cref{fig:sampling_density}).
  \item Self-intersections or tight loops: multiple projections can be locally optimal.
    \texttt{max\_proj\_jump} helps, but jumps are still possible with sharp geometry.
  \item Tangent norm near zero (repeated control points): heading defaults to 0,
    so steering may be arbitrary until geometry improves.
  \item Extremely small lookahead: high steering activity and oscillation.
    Extremely large lookahead: slow convergence and large steady-state CTE.
  \item \texttt{dt} not matching the timer period: integrator accuracy and timing drift.
\end{itemize}

\section{Design intent, expectations, and limitations}
\subsection{Purpose}
The current setup is intentionally simple: a deterministic closed loop for
testing path planning and LOS guidance in simulation without heavy dependencies.

\subsection{What we expect}
\begin{itemize}
  \item With smooth paths and reasonable lookahead, the vessel should converge
    to the path and maintain bounded CTE.
  \item Heading error should be damped by the $k_d r$ term without large overshoot.
  \item Projection should remain stable on benign paths when \texttt{max\_proj\_jump}
    is smaller than the path curvature radius.
\end{itemize}

\subsection{Limitations and risks}
\begin{itemize}
  \item The controller uses constant thrust and no speed regulation; path tracking
    quality depends strongly on the chosen thrust and vessel damping.
  \item The projection is sample-based and approximate; performance degrades on
    sparse samples or sharp corners.
  \item Open paths are not decelerated near the end; without external logic, the
    vessel will keep pushing past the terminal point.
  \item \texttt{max\_proj\_jump} trades stability for reacquisition; values that are
    too small can prevent convergence after large jumps or path switches.
  \item The \texttt{BsplinePath} message includes \texttt{degree} and \texttt{ctrl\_z}
    fields, but the current implementation ignores them.
  \item \texttt{Float32MultiArray} topics lack explicit timestamps or frames, which
    limits synchronization in real systems.
  \item \texttt{/boat\_state} and \texttt{/cmd\_thrust} are absolute topic names, so
    namespacing requires explicit remapping for multi-vehicle setups.
  \item The simulator is planar with simplified damping and no environmental effects;
    it is not a high-fidelity hydrodynamic model.
  \item Automated tests exist for the B-spline utilities, but the controller and
    simulator currently lack direct unit tests.
\end{itemize}

\section{How this stays in sync with code}
This overview is intentionally compact. The most detailed source of truth is the
implementation itself. To keep this document aligned with the code:
\begin{itemize}
  \item Update equations here when you change \texttt{Boat3DOF.dynamics()}.
  \item Update the controller logic when you change \texttt{ControllerNode.control\_loop()}.
  \item Update the spline section when you change \texttt{BSplinePath} or
    \texttt{ProjectionTracker}.
  \item Keep parameter tables aligned with \texttt{sim\_controller\_params.yaml}.
  \item Regenerate \texttt{latex/figures/*.tikz} with
    \texttt{latex/scripts/generate\_figures.py} when projection or sampling changes.
  \item Refresh example figures if coordinate conventions or sign choices change.
\end{itemize}

\end{document}
